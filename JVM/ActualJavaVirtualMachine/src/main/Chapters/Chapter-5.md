### 5.1 一心一意一件事：串行回收器
  串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收和老年代串行回收。
#### 5.1.1 新生代串行回收器
  串行收集器是所有垃圾收集器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。

  串行回收器的两个特点：
  - 只使用单线程进行垃圾回收。
  - 独占式垃圾回收。

  串行收集器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收完成。这种现象称之为“Stop-The-World”。在实时性要求较高的应用场景中，这种现象往往不能被接受。

  虽然不适用于实时性场景，但是串行回收器却是一个成熟且经过长时间生产环境考验的极为高效的收集器。**新生代串行处理器使用复制算法，实现相对简单、逻辑处理特别高效、且没有线程切换的开销。**在诸如单 CPU 处理器等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。

  使用`-XX:+UseSerialGC`参数可以指定使用新生代串行收集器和老年代串行收集器。当虚拟机在 Client 模式下运行时，串行收集器是默认的垃圾收集器。

#### 5.1.2 老年代串行回收器
  **老年代串行回收器使用的是标记压缩算法。**和新生代串行回收器一样，也是串行、独占式的垃圾回收器。老年代垃圾回收通常会使用比新生代回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿较长的时间。

  老年代串行回收器可以和多种新生代回收器配合使用，同时可以作为 CMS 回收器的备用回收器。

  启用老年代串行回收器，常用参数如下：
  - -XX:+UseSerialGC：新生代、老年代都是用串行回收器。
  - -XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
  - -XX:+UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。

### 5.2 人多力量大：并行回收器
#### 5.2.1 新生代 ParNew 回收器
  ParNew 回收器是一个工作在新生代的垃圾回收器。简单的将串行回收器多线程化，回收策略、算法以及参数和新生代串行回收器一样。属于**独占式回收器**，垃圾收集过程中，应用程序会全部暂停。在多核 CPU 的机器上，产生的停顿时间短于串行回收器，单核 CPU 的机器由于多线程的压力，实际表现能力比串行回收器还差。

  开启 ParNew 回收器使用如下参数：
  - -XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
  - -XX:+UseConcMarkSweepGC：新生代使用 ParNew 回收器，老年代使用 CMS。

  ParNew 回收器工作时的线程数量可以使用`-XX:ParallelGCThreads`参数指定，一般设置成 CPU 核数，避免线程数量影响垃圾回收性能。**默认情况下，当 CPU 核数小于8时，ParallelGCThreads 的值等于 CPU 核数，当 CPU 核数大于8时，ParallelGCThreads 的值等于`3 + ((5 * CPU_count) / 8)`。**