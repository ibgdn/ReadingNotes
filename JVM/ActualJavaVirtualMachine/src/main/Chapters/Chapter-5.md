### 5.1 一心一意一件事：串行回收器
  串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收和老年代串行回收。
#### 5.1.1 新生代串行回收器
  串行收集器是所有垃圾收集器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。

  串行回收器的两个特点：
  - 只使用单线程进行垃圾回收。
  - 独占式垃圾回收。

  串行收集器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收完成。这种现象称之为“Stop-The-World”。在实时性要求较高的应用场景中，这种现象往往不能被接受。

  虽然不适用于实时性场景，但是串行回收器却是一个成熟且经过长时间生产环境考验的极为高效的收集器。**新生代串行处理器使用复制算法，实现相对简单、逻辑处理特别高效、且没有线程切换的开销。**在诸如单 CPU 处理器等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。

  使用`-XX:+UseSerialGC`参数可以指定使用新生代串行收集器和老年代串行收集器。当虚拟机在 Client 模式下运行时，串行收集器是默认的垃圾收集器。

#### 5.1.2 老年代串行回收器
  **老年代串行回收器使用的是标记压缩算法。**和新生代串行回收器一样，也是串行、独占式的垃圾回收器。老年代垃圾回收通常会使用比新生代回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿较长的时间。

  老年代串行回收器可以和多种新生代回收器配合使用，同时可以作为 CMS 回收器的备用回收器。

  启用老年代串行回收器，常用参数如下：
  - -XX:+UseSerialGC：新生代、老年代都是用串行回收器。
  - -XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
  - -XX:+UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。

### 5.2 人多力量大：并行回收器
#### 5.2.1 新生代 ParNew 回收器
  ParNew 回收器是一个工作在新生代的垃圾回收器。简单的将串行回收器多线程化，回收策略、算法以及参数和新生代串行回收器一样。属于**独占式回收器**，垃圾收集过程中，应用程序会全部暂停。在多核 CPU 的机器上，产生的停顿时间短于串行回收器，单核 CPU 的机器由于多线程的压力，实际表现能力比串行回收器还差。

  开启 ParNew 回收器使用如下参数：
  - -XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
  - -XX:+UseConcMarkSweepGC：新生代使用 ParNew 回收器，老年代使用 CMS。

  ParNew 回收器工作时的线程数量可以使用`-XX:ParallelGCThreads`参数指定，一般设置成 CPU 核数，避免线程数量影响垃圾回收性能。**默认情况下，当 CPU 核数小于8时，ParallelGCThreads 的值等于 CPU 核数，当 CPU 核数大于8时，ParallelGCThreads 的值等于`3 + ((5 * CPU_count) / 8)`。**

#### 5.2.2 新生代 ParallelGC 回收器
  **新生代 ParallelGC 回收器也是使用复制算法的回收器。**除 ParNew 回收器一样，属于多线程、独占式的回收器之外，还有一个重要特点：关注系统吞吐量。

  新生代 ParallelGC 回收器可以使用如下参数启用：
  - -XX:+UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。
  - -XX:+UseParallelOldGC：新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。

  ParallelGC 回收器提供两个重要参数用于控制系统吞吐量（两个参数互相矛盾）：
  - -XX:MaxGCPauseMillis：设置最大垃圾回收停顿时间。大于0的整数。
    ParallelGC 工作时，会调整 Java 堆或其他参数的大小，尽可能将停顿时间控制在 MaxGCPauseMillis 以内。如果希望减少停顿时间，将值设置的很小，虚拟机会使用一个较小的堆空间，导致垃圾回收变得很频繁，从而增加垃圾回收总时间，降低吞吐量。
  - -XX:GCTimeRatio：设置吞吐量大小。0~100之间的整数。假设 GCTimeRatio 的值为 n，系统花费不超过`1/(1+n)`的时间用于垃圾回收。默认情况下取值是99，即不超过`1/(1+99) = 1%`的时间用于垃圾回收。

  ParallelGC 回收器于 ParNew 回收器的另一个不同之处在于支持一种自适应 GC 调节策略。使用`-XX:+UseAdaptiveSizePolicy`可以打开自适应 GC 策略。在这种模式下，新生代内存大小，Eden 区和 Survivor 区的比例，达到换代级别的年龄会被自动调整，以达到堆空间大小、吞吐量、停顿时间的平衡。

#### 5.2.3 老年代 ParallelOldGC 回收器
  老年代 ParallelOldGC 回收器也是一种多线程并发，同时关注吞吐量的回收器。是一个应用于老年代，并且和 ParallelGC 新生代回收器搭配使用的回收器。

  **ParallelOldGC 回收器使用比较压缩算法，在 JDK1.6 才使用。**

  使用参数`-XX:+UseParallelOldGC`在新生代使用 ParallelGC 回收器，在老年代使用 ParallelOldGC 回收器，是**一对非常关注吞吐量的垃圾回收组合**，对吞吐量敏感的系统可以考虑使用。参数`-XX:ParallelGCThreads`用于设置垃圾回收时的线程数量。

### 5.3 一心多用都不落下：CMS 回收器
  与 ParallelGC 和 ParallelOldGC 不同，CMS（Concurrent Mark Sweep 并发标记清除）垃圾回收器**主要关注于系统停顿时间**，标记清除算法，是一个使用多线程并行回收的垃圾回收器。

#### 5.3.1 CMS 主要工作步骤
  CMS 回收器的主要工作步骤：初始标记、并发标记、预清理、重新标记、并发清除和并发重置。初始标记、重新标记独占系统资源，预清理、并发标记、并发清除和并发重置可以和用户线程一起执行。

  ```mermaid
  graph TD
  A[初始标记 STW:标记根对象] --> B[并发标记 标记所有对象] --> C[预清理 清理前准备以及控制停顿时间] --> D[重新标记 STW:修正并发标记数据] --> E[并发清理 清理垃圾] --> F[并发重置]
  ```
  注：STW： Stop The World

  根据标记清除算法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象；并发清理是在标记完成后，正式回收垃圾对象；并发重置是在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。

  设置参数`-XX:-CMSPrecleaningEnabled`，并发标记后的预清理将会关闭。预清理时并发的，除了为正式清理做准备和检查外，预清理还会尝试控制一次停顿时间。重新标记独占 CPU，新生代 GC 后，立即触发一次重新标记，停顿的时间可能会很长。为了避免这种情况，预处理时，刻意等待一次新生代 GC，根据历史性能数据预测下一次新生代 GC 可能发生的时间，在当前时间和预测时间的中间时刻，进行重标记，最大限度避免新生代 GC 和重新标记时间重合，减少停顿时间。

#### 5.3.2 CMS 主要的设置参数
  启动 CMS 回收器的参数是`-XX:+UseConcMarkSweepGC`。默认启动的并发线程数是`(ParallelGCThreads + 3) / 4`。ParallelGCThreads 表示 GC 并行时使用的线程数量。4个 ParallelGCThreads 线程数，只有一个并发线程，5~8个 ParallelGCThreads 线程数，将会有两个并发线程。

  `-XX:ConcGCThreads`、`-XX:ParallelCMSThreads`参数可以设置并发线程数据。

  **注意：并发是指垃圾回收器和应用线程交替执行，并行是指应用程序停止，同时由多个线程一起执行 GC。**

  CMS 垃圾回收器不是独占式，它进行回收工作时，应用程序仍然在不停地工作。不会等待内存使用饱和后才进行垃圾回收，当堆内存使用率达到某一阈值便开始回收，以确保应用程序在 CMS 工作过程中，依然有足够的空间支持应用程序运行。

  参数`-XX:CMSInitiatingOccupancyFraction`指定老年代回收阈值，默认是68.当老年代的内存空间使用率达到68%时，会执行一次 CMS 回收。如果在 CMS 回收过程中出现内存空间不足的情况，CMS 回收就会失败，虚拟机将启动老年代串行收集器进行垃圾回收，应用程序将完全中断，直至垃圾回收完成，应用程序的停顿时间较长。

  如果内存使用增长缓慢，可以设置一个稍大的阈值，有效降低 CMS 的触发频率，减少老年代回收的次数，较为明显的改善应用程序的性能；如果应用程序内存使用增长很快，则应该适当降低这个阈值，以避免频繁触发老年代串行收集器。

  CMS 垃圾回收器是一个基于标记清除算法的回收器，会造成大量内存碎片，离散的可用空间无法分配较大的对象。即便堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存空间。`-XX:UseCMSCompactAtFullCollection`开关使 CMS 在垃圾收集完成后，进行一次内存碎片整理（不是并发进行）。`-XX:CMSFullGCsBeforeCompaction`参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。