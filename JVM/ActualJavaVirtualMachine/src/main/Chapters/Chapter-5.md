### 5.1 一心一意一件事：串行回收器
  串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收和老年代串行回收。
#### 5.1.1 新生代串行回收器
  串行收集器是所有垃圾收集器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。

  串行回收器的两个特点：
  - 只使用单线程进行垃圾回收。
  - 独占式垃圾回收。

  串行收集器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收完成。这种现象称之为“Stop-The-World”。在实时性要求较高的应用场景中，这种现象往往不能被接受。

  虽然不适用于实时性场景，但是串行回收器却是一个成熟且经过长时间生产环境考验的极为高效的收集器。**新生代串行处理器使用复制算法，实现相对简单、逻辑处理特别高效、且没有线程切换的开销。**在诸如单 CPU 处理器等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。

  使用`-XX:+UseSerialGC`参数可以指定使用新生代串行收集器和老年代串行收集器。当虚拟机在 Client 模式下运行时，串行收集器是默认的垃圾收集器。

#### 5.1.2 老年代串行回收器
  **老年代串行回收器使用的是标记压缩算法。**和新生代串行回收器一样，也是串行、独占式的垃圾回收器。老年代垃圾回收通常会使用比新生代回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿较长的时间。

  老年代串行回收器可以和多种新生代回收器配合使用，同时可以作为 CMS 回收器的备用回收器。

  启用老年代串行回收器，常用参数如下：
  - -XX:+UseSerialGC：新生代、老年代都是用串行回收器。
  - -XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
  - -XX:+UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。

### 5.2 人多力量大：并行回收器
#### 5.2.1 新生代 ParNew 回收器
  ParNew 回收器是一个工作在新生代的垃圾回收器。简单的将串行回收器多线程化，回收策略、算法以及参数和新生代串行回收器一样。属于**独占式回收器**，垃圾收集过程中，应用程序会全部暂停。在多核 CPU 的机器上，产生的停顿时间短于串行回收器，单核 CPU 的机器由于多线程的压力，实际表现能力比串行回收器还差。

  开启 ParNew 回收器使用如下参数：
  - -XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
  - -XX:+UseConcMarkSweepGC：新生代使用 ParNew 回收器，老年代使用 CMS。

  ParNew 回收器工作时的线程数量可以使用`-XX:ParallelGCThreads`参数指定，一般设置成 CPU 核数，避免线程数量影响垃圾回收性能。**默认情况下，当 CPU 核数小于8时，ParallelGCThreads 的值等于 CPU 核数，当 CPU 核数大于8时，ParallelGCThreads 的值等于`3 + ((5 * CPU_count) / 8)`。**

#### 5.2.2 新生代 ParallelGC 回收器
  **新生代 ParallelGC 回收器也是使用复制算法的回收器。**除 ParNew 回收器一样，属于多线程、独占式的回收器之外，还有一个重要特点：关注系统吞吐量。

  新生代 ParallelGC 回收器可以使用如下参数启用：
  - -XX:+UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。
  - -XX:+UseParallelOldGC：新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。

  ParallelGC 回收器提供两个重要参数用于控制系统吞吐量（两个参数互相矛盾）：
  - -XX:MaxGCPauseMillis：设置最大垃圾回收停顿时间。大于0的整数。
    ParallelGC 工作时，会调整 Java 堆或其他参数的大小，尽可能将停顿时间控制在 MaxGCPauseMillis 以内。如果希望减少停顿时间，将值设置的很小，虚拟机会使用一个较小的堆空间，导致垃圾回收变得很频繁，从而增加垃圾回收总时间，降低吞吐量。
  - -XX:GCTimeRatio：设置吞吐量大小。0~100之间的整数。假设 GCTimeRatio 的值为 n，系统花费不超过`1/(1+n)`的时间用于垃圾回收。默认情况下取值是99，即不超过`1/(1+99) = 1%`的时间用于垃圾回收。

  ParallelGC 回收器于 ParNew 回收器的另一个不同之处在于支持一种自适应 GC 调节策略。使用`-XX:+UseAdaptiveSizePolicy`可以打开自适应 GC 策略。在这种模式下，新生代内存大小，Eden 区和 Survivor 区的比例，达到换代级别的年龄会被自动调整，以达到堆空间大小、吞吐量、停顿时间的平衡。

#### 5.2.3 老年代 ParallelOldGC 回收器
  老年代 ParallelOldGC 回收器也是一种多线程并发，同时关注吞吐量的回收器。是一个应用于老年代，并且和 ParallelGC 新生代回收器搭配使用的回收器。

  **ParallelOldGC 回收器使用比较压缩算法，在 JDK1.6 才使用。**

  使用参数`-XX:+UseParallelOldGC`在新生代使用 ParallelGC 回收器，在老年代使用 ParallelOldGC 回收器，是**一对非常关注吞吐量的垃圾回收组合**，对吞吐量敏感的系统可以考虑使用。参数`-XX:ParallelGCThreads`用于设置垃圾回收时的线程数量。

### 5.3 一心多用都不落下：CMS 回收器
  与 ParallelGC 和 ParallelOldGC 不同，CMS（Concurrent Mark Sweep 并发标记清除）垃圾回收器**主要关注于系统停顿时间**，标记清除算法，是一个使用多线程并行回收的垃圾回收器。

#### 5.3.1 CMS 主要工作步骤
  CMS 回收器的主要工作步骤：初始标记、并发标记、预清理、重新标记、并发清除和并发重置。初始标记、重新标记独占系统资源，预清理、并发标记、并发清除和并发重置可以和用户线程一起执行。

  ```mermaid
  graph TD
  A[初始标记 STW:标记根对象] --> B[并发标记 标记所有对象] --> C[预清理 清理前准备以及控制停顿时间] --> D[重新标记 STW:修正并发标记数据] --> E[并发清理 清理垃圾] --> F[并发重置]
  ```
  注：STW： Stop The World

  根据标记清除算法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象；并发清理是在标记完成后，正式回收垃圾对象；并发重置是在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。

  设置参数`-XX:-CMSPrecleaningEnabled`，并发标记后的预清理将会关闭。预清理时并发的，除了为正式清理做准备和检查外，预清理还会尝试控制一次停顿时间。重新标记独占 CPU，新生代 GC 后，立即触发一次重新标记，停顿的时间可能会很长。为了避免这种情况，预处理时，刻意等待一次新生代 GC，根据历史性能数据预测下一次新生代 GC 可能发生的时间，在当前时间和预测时间的中间时刻，进行重标记，最大限度避免新生代 GC 和重新标记时间重合，减少停顿时间。

#### 5.3.2 CMS 主要的设置参数
  启动 CMS 回收器的参数是`-XX:+UseConcMarkSweepGC`。默认启动的并发线程数是`(ParallelGCThreads + 3) / 4`。ParallelGCThreads 表示 GC 并行时使用的线程数量。4个 ParallelGCThreads 线程数，只有一个并发线程，5~8个 ParallelGCThreads 线程数，将会有两个并发线程。

  `-XX:ConcGCThreads`、`-XX:ParallelCMSThreads`参数可以设置并发线程数据。

  **注意：并发是指垃圾回收器和应用线程交替执行，并行是指应用程序停止，同时由多个线程一起执行 GC。**

  CMS 垃圾回收器不是独占式，它进行回收工作时，应用程序仍然在不停地工作。不会等待内存使用饱和后才进行垃圾回收，当堆内存使用率达到某一阈值便开始回收，以确保应用程序在 CMS 工作过程中，依然有足够的空间支持应用程序运行。

  参数`-XX:CMSInitiatingOccupancyFraction`指定老年代回收阈值，默认是68.当老年代的内存空间使用率达到68%时，会执行一次 CMS 回收。如果在 CMS 回收过程中出现内存空间不足的情况，CMS 回收就会失败，虚拟机将启动老年代串行收集器进行垃圾回收，应用程序将完全中断，直至垃圾回收完成，应用程序的停顿时间较长。

  如果内存使用增长缓慢，可以设置一个稍大的阈值，有效降低 CMS 的触发频率，减少老年代回收的次数，较为明显的改善应用程序的性能；如果应用程序内存使用增长很快，则应该适当降低这个阈值，以避免频繁触发老年代串行收集器。

  CMS 垃圾回收器是一个基于标记清除算法的回收器，会造成大量内存碎片，离散的可用空间无法分配较大的对象。即便堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存空间。`-XX:UseCMSCompactAtFullCollection`开关使 CMS 在垃圾收集完成后，进行一次内存碎片整理（不是并发进行）。`-XX:CMSFullGCsBeforeCompaction`参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。

#### 5.3.3 CMS 日志分析
  CMS 回收器工作时的日志输出如下：
  ```
  1.313: [GC [1 CMS-initial-mark: 69112K(136576K)] 77037K(198016K), 0.0120453 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
  1.325: [CMS-concurrent-mark-start]
  ...
  1.406: [CMS-concurrent-mark: 0.072/0.082 secs] [Times: user=0.17 sys=0.00, real=0.08 secs]
  1.406: [CMS-concurrent-preclean-start]
  ...
  1.409: [CMS-concurrent-abortable-preclean-start]
  ...
  1.423: [GC[YG occupancy: 35483 K (61440K)]1.423: [Rescan (parallel) , 0.0102064 secs] 1.433: [weak refs processing, 0.0000142 secs]1.433: [scrub string table, 0.0000298 secs] [1 CMS-remark: 74166K(136576K)] 109650K(198016K), 0.0103386 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
  1.433: [CMS-concurrent-sweep-start]
  ```
  以上是一次 CMS 内存垃圾回收的部分输出信息，包括了初始化标记、并发标记、预清理、重新标记、并发清理和并发重置等几个重要阶段。

  1.409秒时，发生 abortable-preclean，表示 CMS 开始等待一次新生代 GC。之后 ParNew 垃圾回收器工作，abortable-preclean 终止（ParNew 工作信息未展示）。CMS 根据之前新生代 GC 的情况，将重新标记的时间放置在一个最不可能和下一次新生代 GC 重叠的时刻，通常为两次新生代 GC 的中间点。

  CMS 回收器在运行时还可能输出如下信息：
  ```
  33.348: [Full GC 33.348: [CMS33.347: [CMS-concurrent-sweep: 0.034/0.036 secs] [Times: user=0.11 sys=0.03, real=0.03 secs]
  (concurrent mode failure): 47066K->39901K(49152K), 0.3896802 secs] 60771K->39901K(63936K), [CMS Perm : 22529K->22529K(32768K)], 0.3897989 secs] [Times: user=0.39 sys=0.00, real=0.39 secs]
  ```

  `(concurrent mode failure)`显示 CMS 垃圾回收器并发收集失败。很可能是由于应用程序在运行过程中老年代空间不够所致。如果在 CMS 工作过程中，出现非常频繁的并发模式失败，就应该考虑进行调整，尽可能预留一个较大的老年代空间。或者设置一个较小的`-XX:CMSInitiatingOccupancyFraction`参数，降低 CMS 触发的阈值，使 CMS 在执行过程中，仍然有较大的老年代空闲空间供应用程序使用。

  **注意：CMS 回收器是一个关注停顿的垃圾回收器。同时 CMS 回收器在部分工作流程中，可以与用户程序同时运行，从而降低应用程序的停顿时间。**

### 5.4 未来我做主：G1 回收器
  G1 回收器（Garbage-First）在 JDK 1.7中正式使用的全新垃圾回收器，为了取代 CMS 回收器。G1 属于分代垃圾回收器，会区分年轻代和老年代，依然有 Eden 区和 Survivor 区，从堆的结构看，并不要求整个 Eden 区、年轻代或者老年代都连续。

  G1 使用了分区算法，特点如下：
  - **并行性**：G1 在垃圾回收期间，可以由多个 GC 线程同时工作，有效利用多核计算能力。
  - **并发性**：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，一般来说，不会在整个回收期间完全阻塞应用程序。
  - **分代 GC**：G1 是分代垃圾回收器，同时兼顾年轻代和老年代（其他垃圾回收器，要么工作在年轻代，要么工作在老年代）。
  - **空间整理**：G1 在垃圾回收过程中，会适当的移动对象。CMS 只是简单的标记、清理对象，若干次 GC 后 CMS 必须进行一次碎片整理；G1 每次回收都会有效地复制对象，减少空间碎片。
  - **可预见性**：由于分区，G1 可以只选取部分区域进行内存垃圾回收，减少垃圾回收范围，控制全局停顿。

#### 5.4.1 G1 的内存划分和主要收集过程
  G1 回收器将堆内存进行分区，每次 GC 时，只收集其中几个区域，以此控制垃圾回收产生的停顿时间。

  G1 垃圾回收的四个阶段：
  - 新生代 GC
  - 并发标记周期
  - 混合收集
  - 如果需要，可能会进行 Full GC

#### 5.4.2 G1 的新生代 GC
  新生代 GC 的主要工作是回收 Eden 区和 Survivor 区。一旦 Eden 区被占满，新生代 GC 就会启动。新生代 GC 只处理 Eden 区和 Survivor 区，内存垃圾回收后，所有的 Eden 区都应该被清空，而 Survivor 区被收集一部分数据，至少仍然存在一个 Survivor 区（与其他新生代收集器没有太大变化）。重要变化是老年代的数据区域增多，因为部分 Survivor 区或者 Eden 区的对象可能会晋升到老年代。

  新生代 GC 发生后，如果打开了 PrintGCDetails 选项，就可以得到类似日志输出信息：
  ```
  0.336: [GC pause (young), 0.0063051 secs]
  ...
  [Eden: 235.0M(235.0M)->0.0B(229.0M) Survivors: 5120.0K->11.0M Heap:239.2M(400.0M)->10.5M(400.0M)]
  [Times: user=0.06 sys=0.00, real=0.01 secs]
  ```
  和其他内存垃圾回收器的日志相比，G1 的日志内容非常丰富。我们最为关心的是 GC 的停顿时间以及回收情况。从日志中可以看到，Eden 区原本占用235MB空间，回收后被清空，Survivor 区从5MB增长到了11MB，这是因为部分对象从 Eden 区复制到 Survivor 区，整个堆合计为400MB，从回收前的239MB下降到10.5MB。

#### 5.4.3 G1 的并发标记周期
  G1 的并发阶段和 CMS 有点类似，都是为了降低 STW 时间，将可以和应用程序并发的部分单独提取出来执行。

  并发标记周期分为如下步骤：
  - **初始标记**：标记从根节点直接可达的对象。这个阶段会伴随一次新生代 GC，会产生全局停顿，应用程序线程在这个阶段必须停止执行。
  - **根区域扫描**：初始标记必然会伴随一次新生代 GC，初始标记后，Eden 区被清空，存活对象被移入 Survivor 区。在这个阶段，将扫描由 Survivor 区直接可达的老年代区域，并标记这些直接可达的对象。这个过程可以和应用程序并发执行的，但是根区域扫描不能和新生代 GC 同时执行（因为根区域扫描依赖 Survivor 区的对象，而新生代 GC 会修改这个区域），因此如果恰巧在此时需要进行新生代 GC，就需要等待根区域扫描结束后才能进行。如果发生这种情况，这次新生代 GC 的时间就会延长。
  - **并发标记**：和 CMS 类似，并发标记将会扫描并查找整个堆的存活对象，并做好标记。这是一个并发的过程，并且这个过程可以被一次新生代 GC 打断。
  - **重新标记**：和 CMS 一样，重新标记会产生应用程序停顿。在并发标记过程中，应用程序依然在运行，标记结果可能需要进行修正，在此对上一次的标记结果进行补充。在 G1 中，这个过程使用 SATB（Snapshot-At-The-Beginning）算法完成，即 G1 会在标记之初为存活对象创建一个快照（有助于加速重新标记速度）。
  - **独占清理**：这个阶段会引起停顿。计算各个区域的存活对象和 GC 回收比例并进行排序，识别可供混合回收的区域。在这个阶段，还会更新记忆集（Remembered Set）。该阶段给出了需要被混合回收的区域并进行标记，在混合回收阶段，需要这些信息。
  - **并发清理阶段**：识别并清理完全空闲的区域。并发清理，不会引起停顿。

#### 5.4.4 混合回收
  并发标记周期中，对象回收的比例相当低；并发标记周期后，G1 已经明确知道哪些区域含有较多的垃圾对象；混合回收阶段，可以专门针对这些区域进行回收。G1（Garbage First Garbage Collector）垃圾比例高优先回收的垃圾回收器。

  混合回收既会执行正常的年轻代 GC，又会选取一些被标记的老年代区域进行回收。新生代 GC 会清空 Eden 区，另外被标记为高垃圾比例的区域也会被清空。

  混合 GC 会产生如下日志：
  ```
  1.904: [GC pause (mixed), 0.0073135 secs]
  ...
    [Eden: 4096.0K(4096.0K)->0.0B(53.0M) Survivors: 6144.0K->2048.0K Heap:127.3M(200.0M)->123.6M(200.0M)]
  [Times: user=0.00 sys=0.00, real=0.01 secs]
  ```
  混合 GC 会执行多次，直到回收足够的内存空间，之后触发一次新生代 GC。之后又可能会发生一次并发标记周期的处理，最后，引起混合 GC 执行。

  ```mermaid
  graph TD
  A[年轻代 GC] --> B[并发标记周期] --> C[混合 GC] --> A
  ```

#### 5.4.5 必要时的 Full GC
  并发垃圾回收器（CMS、G1都是）是应用程序和 GC 线程交替工作，在内存空间不足的时候会进行 Full GC。

  Full GC 日志：
  ```
  24.909: [GC concurrent-mark-start]
  24.909: [Full GC 898M->896M(900M), 0.7505595 secs]
      [Eden: 0.0B(45.0M)->0.0B(45.0M) Survivors: 0.0B->0.0B Heap: 898.7M(900.0M)->896.2M(900.0M)]
    [Times: user=1.05 sys=0.00, real=0.75 secs]
  25.660: [GC concurrent-mark-abort]
  ```
  如果在混合 GC 时发生空间不足或者在新生代 GC 时，Survivor 区和老年代无法容纳幸存对象，都会导致一次 Full GC 发生。