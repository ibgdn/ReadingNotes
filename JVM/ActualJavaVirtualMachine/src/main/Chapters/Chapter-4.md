### 4.1 内存管理清洁工：认识垃圾回收
  垃圾回收（Garbage Collection，简称 GC）中的垃圾指存在于内存中的、不会再被使用的对象，Java 程序运行过程中如果没有垃圾回收，会因为对象的不断创建，内存空间不够，导致内存溢出。

  垃圾回收并不是 Java 虚拟机独创，早在20世纪60年代，垃圾回收就已经被 Lisp 语言所使用。自动化的内存管理方式已经成为现代开发语言必备的标准。

### 4.2 清洁工具大 PK：讨论常用的垃圾回收算法
#### 4.2.1 引用计数法（Reference Counting）
  引用计数法是最经典也是最古老的一种垃圾收集算法。对于一个对象 object，只要任何一个对象引用了对象 object，则该对象的引用计数器就加1，引用失效时，引用计数器就减1。object 的引用计数器的值为0时，将不可能被使用。

  引用计数器的实现非常简单：为每个对象配备一个整型的计数器即可。但是却有两个非常严重的问题：
  - **无法处理循环引用**。
    两个对象相互引用，两个对象的引用计数器都不为0，同时系统中不存在任何对象引用这两个对象。此时，这两个对象应该被垃圾回收，但是因为互相引用，垃圾回收器无法识别，可能会引起内存泄漏。

  - 引用计数器要求在每次因引用产生和消除的时候，需要伴随一个加法和减法操作，**对性能有影响**。

  **注意：由于单纯的引用计数算法隐含着循环引用以及性能问题，Java 虚拟机并未选择此算法作为垃圾回收算法。**

  【名词解释】
  - 可达对象
    通过根对象进行引用搜索，可以到达的对象。

  - 不可达对象
    通过根对象进行引用搜索，最终没有被引用的对象。

#### 4.2.2 标记清除算法（Mark-Sweep）
  标记清除算法是现代垃圾回收算法的思想基础。将垃圾回收分为两个阶段：标记阶段和清除阶段。标记阶段从根节点开始，标记所有可达的对象，未被标记的对象就是未被引用的垃圾对象；在清除阶段将清除所有未被标记的对象。

  **标记清除算法可能产生的最大问题就是空间碎片。**回收后的空间不连续，在对象的堆空间分配过程中，尤其是大对象内存分配，不连续内存空间的工作效率要低于连续的空间（该算法的最大缺点）。

  **注意：标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。**

#### 4.2.3 复制算法（Copying）
  复制算法的核心思想是：将原有的内存空间分成两部分，每次只使用其中一部分，垃圾回收时，将正在使用的内存中的存活对象复制到另外一部分中，清除正在使用的内存部分对象，交换两部分的角色，完成垃圾回收。

  如果系统中垃圾对象很多，复制的存活对象较少，复制算法的效率会很高；存活对象被统一复制到新的内存空间，回收后的空间没有碎片。但是复制算法真正使用的内存空间只有总内存空间的一半。

  Java 新生代串行垃圾回收器使用了复制算法的思想：新生代分为 Eden 空间、From 空间和 To 空间3部分。From 空间和 To 空间也被称为 Survivor（幸存者）空间，是两块大小相等、地位相等、可进行角色互换的空间块，用于存放未被回收的对象。

  【名词解释】
  - 新生代
    存放年轻对象（刚刚创建或者经历垃圾回收次数较少未达到换代级别的对象）的堆空间。

  - 老年代
    存放老年对象（经历多次垃圾回收并达到换代级别的对象）的堆空间。

  采用复制算法进行垃圾回收时，Eden 空间中的存活对象会被复制到 To 空间（未被使用的 Survivor 空间），From 空间（正在使用的 Survivor 空间）的年轻对象会被复制到 To 空间，但是大对象或者是达到换代级别的对象将会直接进入老年代，如果 To 空间已满，对象将会直接进入老年代。Eden 空间和 From 空间中的剩余对象都是垃圾对象，将会被直接清空，To 空间存放垃圾回收后的存活对象。

  改进的复制算法，既保证了空间的连续性，又避免了大量的内存空间浪费。

  **注意：复制算法比较适用于新生代（新生代垃圾对象通常会多于存活对象）**