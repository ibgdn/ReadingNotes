### 4.1 内存管理清洁工：认识垃圾回收
  垃圾回收（Garbage Collection，简称 GC）中的垃圾指存在于内存中的、不会再被使用的对象，Java 程序运行过程中如果没有垃圾回收，会因为对象的不断创建，内存空间不够，导致内存溢出。

  垃圾回收并不是 Java 虚拟机独创，早在20世纪60年代，垃圾回收就已经被 Lisp 语言所使用。自动化的内存管理方式已经成为现代开发语言必备的标准。

### 4.2 清洁工具大 PK：讨论常用的垃圾回收算法
#### 4.2.1 引用计数法（Reference Counting）
  引用计数法是最经典也是最古老的一种垃圾收集算法。对于一个对象 object，只要任何一个对象引用了对象 object，则该对象的引用计数器就加1，引用失效时，引用计数器就减1。object 的引用计数器的值为0时，将不可能被使用。

  引用计数器的实现非常简单：为每个对象配备一个整型的计数器即可。但是却有两个非常严重的问题：
  - **无法处理循环引用**。
    两个对象相互引用，两个对象的引用计数器都不为0，同时系统中不存在任何对象引用这两个对象。此时，这两个对象应该被垃圾回收，但是因为互相引用，垃圾回收器无法识别，可能会引起内存泄漏。

  - 引用计数器要求在每次因引用产生和消除的时候，需要伴随一个加法和减法操作，**对性能有影响**。

  **注意：由于单纯的引用计数算法隐含着循环引用以及性能问题，Java 虚拟机并未选择此算法作为垃圾回收算法。**

  【名词解释】
  - 可达对象
    通过根对象进行引用搜索，可以到达的对象。

  - 不可达对象
    通过根对象进行引用搜索，最终没有被引用的对象。

#### 4.2.2 标记清除算法（Mark-Sweep）
  标记清除算法是现代垃圾回收算法的思想基础。将垃圾回收分为两个阶段：标记阶段和清除阶段。标记阶段从根节点开始，标记所有可达的对象，未被标记的对象就是未被引用的垃圾对象；在清除阶段将清除所有未被标记的对象。

  **标记清除算法可能产生的最大问题就是空间碎片。**回收后的空间不连续，在对象的堆空间分配过程中，尤其是大对象内存分配，不连续内存空间的工作效率要低于连续的空间（该算法的最大缺点）。

  **注意：标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。**

#### 4.2.3 复制算法（Copying）
  复制算法的核心思想是：将原有的内存空间分成两部分，每次只使用其中一部分，垃圾回收时，将正在使用的内存中的存活对象复制到另外一部分中，清除正在使用的内存部分对象，交换两部分的角色，完成垃圾回收。

  如果系统中垃圾对象很多，复制的存活对象较少，复制算法的效率会很高；存活对象被统一复制到新的内存空间，回收后的空间没有碎片。但是复制算法真正使用的内存空间只有总内存空间的一半。

  Java 新生代串行垃圾回收器使用了复制算法的思想：新生代分为 Eden 空间、From 空间和 To 空间3部分。From 空间和 To 空间也被称为 Survivor（幸存者）空间，是两块大小相等、地位相等、可进行角色互换的空间块，用于存放未被回收的对象。

  【名词解释】
  - 新生代
    存放年轻对象（刚刚创建或者经历垃圾回收次数较少未达到换代级别的对象）的堆空间。

  - 老年代
    存放老年对象（经历多次垃圾回收并达到换代级别的对象）的堆空间。

  采用复制算法进行垃圾回收时，Eden 空间中的存活对象会被复制到 To 空间（未被使用的 Survivor 空间），From 空间（正在使用的 Survivor 空间）的年轻对象会被复制到 To 空间，但是大对象或者是达到换代级别的对象将会直接进入老年代，如果 To 空间已满，对象将会直接进入老年代。Eden 空间和 From 空间中的剩余对象都是垃圾对象，将会被直接清空，To 空间存放垃圾回收后的存活对象。

  改进的复制算法，既保证了空间的连续性，又避免了大量的内存空间浪费。

  **注意：复制算法比较适用于新生代（新生代垃圾对象通常会多于存活对象）**

#### 4.2.4 标记压缩算法（Mark-Compact）
  复制算法的高效建立在存活对象少、垃圾对象多的前提下。老年代的对象大部分都是存活对象，如果继续使用复制算法，将会付出很高的成本。

  标记压缩算法是一种老年代的垃圾回收算法，在标记清除算法的基础上做了一些优化。从根节点开始，对所有可达对象做标记，之后将所有存活的对象压缩到内存的一端，清理边界外所有的空间。既避免了碎片的产生，又不需要两块相同空间大小的内存空间，性价比较高。

  标记压缩算法的最终效果等同于执行标记清除算法后，再进行一次内存碎片整理，也可以被称为标记清除压缩（Mark-Sweep-Compact）算法。

#### 4.2.5 分代算法（Generational Collecting）
  分代算法将内存空间根据内存对象的特点分成几块，根据每块内存空间的特点，使用不同的回收算法，以提高垃圾回收的效率。

  Java 虚拟机会将大部分新建对象放入新生代，新生代对象朝生夕灭，大部分对象会被很快回收，新生代适合使用复制算法；经历过多次垃圾回收，达到换代级别的对象将会进入老年代，继续在老年代使用复制算法回收，将会出现回收效率低于新生代的情况（老年代需要复制大量对象），可以在老年代使用标记压缩或标记清除算法，提高垃圾回收效率。

  新生代垃圾回收频率高，耗时短；老年代垃圾回收频率低，耗时长。

  为了支持高频新生代垃圾回收，虚拟机使用的数据结构叫卡表（Card Table）。卡表是一个比特位的集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。卡表中每一位表示老年代4KB的空间，卡表记录为0的老年代区域没有任何对象指向新生代，卡表位为1的区域表示对象包含新生代引用，新生代 GC 时只扫描卡表位为1的老年代，加快新生代的回收速率。

#### 4.2.6 分区算法（Region）
  分代算法按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区域，每一个区域独立使用，独立回收。可以控制一次回收多个小区域。

  一般在相同条件下，堆空间越大，一次完整 GC 所需要的时间就越长，从而产生的停顿就越长。为了更好的控制 GC 停顿时间，将一块大的内存区域分割成多个小块，根据目标停顿时间，每次合理回收若干小块，而不是整个堆空间，从而减少一次 GC 所产生的停顿。

### 4.3 谁才是真正的垃圾：判断可触及性
  一个对象可触及性包含三种状态：
  - 可触及的
    从根节点开始，可以到达这个对象
  - 可复活的
    对象的所有引用都被释放，但是对象有可能在 finalize() 方法中复活
  - 不可触及的（可以被回收）
    对象的 finalize() 方法被调用，并且没有复活，就会进入不可触及状态。不可触及的对象不能被复活，因为 finalize() 方法只会被调用一次。

#### 4.3.1 对象的复活
  对象复活：[ReliveObject](../java/com/ibgdn/chapter_4/ReliveObject.java)

  输出结果：
  ```
  The first GC
  ReliveObject finalize called
  object is not null: I am ReliveObject
  The second GC
  object is null
  ```

  第一次 GC 时，对象被复活了，第二次 GC 时，对象被回收。第一次 GC 时，object 对象在 finalize() 方法调用之前，**虽然系统的引用被清除，但是作为实例方法，对象的 this 引用依然会被传入方法内部，如果引用外泄，对象就会复活，变为可触及状态。**finalize() 方法只会被调用一次，第二次 GC 不会将对象复活，对象被回收。

  注意：finalize() 方法是一个非常糟糕的模式，不推荐调用释放资源。因为 finalize() 方法有可能发生引用外泄，在无意中复活对象；finalize() 方法被系统调用，调用时间不明确，因为不是一个好的资源释放方案，推荐在`try-catch-finally`语句中进行资源的释放。

#### 4.3.2 引用和可触及性的强度
  Java 语言提供了4个级别的引用：强引用、软引用、弱引用、虚引用。强引用就是程序中一般使用的引用类型，强引用的对象可触及，不会被回收；软引用、弱引用、虚引用的对象是软可触及、弱可触及、虚可触及，在一定条件下，都可以被回收。

  ```java
  StringBuffer str = new StringBuffer("Hello world!");
  ```
  以上代码段在方法体内运行，局部变量`str`被分配在栈上，对象`StringBuffer`实例被分配到堆上。局部变量`str`指向`StringBuffer`实例所在的堆空间，通过`str`可以操作实例，`str`就是`StringBuffer`实例的强引用。

  ```java
  StringBuffer str1 = str;
  ```
  `str`所指向的对象也将被`str1`所指向，同时在局部变量表会分配存放`str1`变量的空间。`StringBuffer`实例有两个引用。

  示例中的两个引用都是强引用，具备以下特点：
  - 强引用可以直接访问目标对象
  - 强引用所指向的对象在任何时候都不会被系统回收，虚拟机即便抛出 OOM 异常，也不会回收强引用所指向对象
  - 强引用对象可能导致内存泄漏