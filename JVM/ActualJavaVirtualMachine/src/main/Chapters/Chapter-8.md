### 8.1 完全就是锁存在的理由：锁的基本概念和实现
  锁是多线程软件开发的必要工具之一，它的基本作用是保护临界区资源不会被多个线程同时访问而受到破坏。如果由于多线程访问造成对象数据的不一致，那么系统运行将会得到错误的结果。通过锁，可以让多个线程排队，一个一个地进入临界区访问目标对象，使目标对象的状态总是保持一致，这也就是锁存在的价值。

#### 8.1.1 理解线程安全
  通过锁，可以实现线程安全。对于线程安全，简单的理解就是，在多线程环境下，无论多个线程如何访问目标对象，目标对象的状态应该始终是保持一致的，线程的行为也总是正确的。

  简单示例说明线程安全：

  线程 A 和线程 B 在数据库中分别读入两条学生成绩记录，线程 A 读入小明98分，线程 B 读入小王考77分。现在需要将从数据库里得到的数据保存到对象实例 S 上，在进行其他相应的业务逻辑处理。此时，对象实例 S 就是临界区资源。如果没有锁对 S 进行保护，任由两个线程随意处理，由于线程间的无序性访问，一种可能的访问结果是：线程 A 将学生名“小明”赋予对象 S，接着线程 B 将学生名“小王”赋予对象 S，覆盖线程 A 的操作。然后，线程 B 将成绩77分赋予对象 S，最后线程 A 将成绩98分赋予对象 S，覆盖了线程 B 的操作。这一组操作得到的结果是，对象 S 中保存了部分小明的数据（成绩），部分小王的数据（学生名），显然这样一个对象是没有任何意义的，也就是对象处于一种不一致的状态，这也正是线程不安全导致的恶果。

  要处理这个问题就可以使用锁来解决。对于对象 S 的所有操作使用锁进行控制，每一次只允许一个线程对其操作，如果线程 A 先获得锁，那么线程 A 将完成它对对象 S 的所有处理，最后释放锁。而线程 B 由于没能请求到锁，就会进行等待，直到线程 A 释放了锁，线程 B 才得以获得锁。在这种情况下，只有在被锁保护的代码段内，对象的状态会出现短暂的不一致（幸运的是，这种状态被锁保护，因此其他线程也无法观察到这种状态），但只要线程 A 或者线程 B 完成了它的工作，对象 S 的状态就是一致的，即对象 S 保存的数据不是小明的，就是小王的，而不是两者的混合体。

  数据的不一致不仅会使得程序给出错误的结果，也可能导致程序异常崩溃。

  [ArrayList 在多线程下使用](../java/com/ibgdn/chapter_8/ThreadUnSafe.java)

  两个线程同时向 List 集合中增加数据，由于 ArrayList 不是线程安全的，很可能抛出如下错误（也有可能不出错）。

  输出结果：
  ```
  Exception in thread "Thread-1" java.lang.ArrayIndexOutOfBoundsException: 10
	  at java.util.ArrayList.add(ArrayList.java:463)
	  at com.ibgdn.chapter_8.ThreadUnSafe$AddToList.run(ThreadUnSafe.java:35)
	  at java.lang.Thread.run(Thread.java:748)
  ```

  出现这个问题，是因为两个线程同时对 ArrayList 进行写操作，破坏了 ArrayList 内部数据的一致性，导致其中一个线程访问了错误的数组索引。简单的修正方法是使用 Vector 代替 ArrayList，Vector 通过内部锁实现对 List 对象控制。

#### 8.1.2 对象头和锁
  Java 虚拟机的实现中，每个对象都有一个对象头，用于保存对象的系统信息。对象头中有一个称为 Mark Word 的部分，是实现锁的关键。Mark Word 在32位系统中占32位数据，64位系统中占64位数据。是一个多功能的数据区，可以存放对象的哈希值、对象年龄、锁的指针（是否占有锁，占有哪个锁）等信息。

  32位系统，普通对象的对象头：
  ```
  hash:25 ------------>| age:4  biased_lock:1   lock:2
  ```
  25位比特表示对象的哈希值，4位比特表示对象的年龄，1位比特表示是否为偏向锁，2位比特表示锁的信息。

  偏向锁对象格式如下：
  ```
  [JavaThread*  |   epoch   |   age |   1   |   01]
  ```
  前23位比特表示持有偏向锁的线程，后续2位比特表示偏向锁的时间戳（epoch），4位比特表示对象年龄，年龄后1位比特固定为1，表示偏向锁，最后2位为01表示可偏向/未锁定。

  当对象处于轻量级锁锁定时，Mark Word 如下（00表示最后两位的值）：
  ```
  [ptr  |   00] locked
  ```
  此时，它指向存放在获得锁的线程栈中的该对象真实对象头。

  当对象处于重量级锁定时，Mark Word 如下：
  ```
  [ptr  |   01] monitor
  ```
  此时，最后2位为10，整个 Mark Word 表示指向 Monitor 的指针。

  对象处于普通的未锁定状态，格式如下：
  ```
  [header   |   0   |   01] unlocked
  ```
  前29位表示对象的哈希值、年龄等信息。倒数第3位为0，最后两位01，表示未锁定。可以发现，最后两位的值和偏向状态时是一样的，此时，虚拟机正是通过倒数第3位比特来区分是否是偏向锁。