### 8.1 完全就是锁存在的理由：锁的基本概念和实现
  锁是多线程软件开发的必要工具之一，它的基本作用是保护临界区资源不会被多个线程同时访问而受到破坏。如果由于多线程访问造成对象数据的不一致，那么系统运行将会得到错误的结果。通过锁，可以让多个线程排队，一个一个地进入临界区访问目标对象，使目标对象的状态总是保持一致，这也就是锁存在的价值。

#### 8.1.1 理解线程安全
  通过锁，可以实现线程安全。对于线程安全，简单的理解就是，在多线程环境下，无论多个线程如何访问目标对象，目标对象的状态应该始终是保持一致的，线程的行为也总是正确的。

  简单示例说明线程安全：

  线程 A 和线程 B 在数据库中分别读入两条学生成绩记录，线程 A 读入小明98分，线程 B 读入小王考77分。现在需要将从数据库里得到的数据保存到对象实例 S 上，在进行其他相应的业务逻辑处理。此时，对象实例 S 就是临界区资源。如果没有锁对 S 进行保护，任由两个线程随意处理，由于线程间的无序性访问，一种可能的访问结果是：线程 A 将学生名“小明”赋予对象 S，接着线程 B 将学生名“小王”赋予对象 S，覆盖线程 A 的操作。然后，线程 B 将成绩77分赋予对象 S，最后线程 A 将成绩98分赋予对象 S，覆盖了线程 B 的操作。这一组操作得到的结果是，对象 S 中保存了部分小明的数据（成绩），部分小王的数据（学生名），显然这样一个对象是没有任何意义的，也就是对象处于一种不一致的状态，这也正是线程不安全导致的恶果。

  要处理这个问题就可以使用锁来解决。对于对象 S 的所有操作使用锁进行控制，每一次只允许一个线程对其操作，如果线程 A 先获得锁，那么线程 A 将完成它对对象 S 的所有处理，最后释放锁。而线程 B 由于没能请求到锁，就会进行等待，直到线程 A 释放了锁，线程 B 才得以获得锁。在这种情况下，只有在被锁保护的代码段内，对象的状态会出现短暂的不一致（幸运的是，这种状态被锁保护，因此其他线程也无法观察到这种状态），但只要线程 A 或者线程 B 完成了它的工作，对象 S 的状态就是一致的，即对象 S 保存的数据不是小明的，就是小王的，而不是两者的混合体。

  数据的不一致不仅会使得程序给出错误的结果，也可能导致程序异常崩溃。

  [ArrayList 在多线程下使用](../java/com/ibgdn/chapter_8/ThreadUnSafe.java)

  两个线程同时向 List 集合中增加数据，由于 ArrayList 不是线程安全的，很可能抛出如下错误（也有可能不出错）。

  输出结果：
  ```
  Exception in thread "Thread-1" java.lang.ArrayIndexOutOfBoundsException: 10
	  at java.util.ArrayList.add(ArrayList.java:463)
	  at com.ibgdn.chapter_8.ThreadUnSafe$AddToList.run(ThreadUnSafe.java:35)
	  at java.lang.Thread.run(Thread.java:748)
  ```

  出现这个问题，是因为两个线程同时对 ArrayList 进行写操作，破坏了 ArrayList 内部数据的一致性，导致其中一个线程访问了错误的数组索引。简单的修正方法是使用 Vector 代替 ArrayList，Vector 通过内部锁实现对 List 对象控制。

#### 8.1.2 对象头和锁
  Java 虚拟机的实现中，每个对象都有一个对象头，用于保存对象的系统信息。对象头中有一个称为 Mark Word 的部分，是实现锁的关键。Mark Word 在32位系统中占32位数据，64位系统中占64位数据。是一个多功能的数据区，可以存放对象的哈希值、对象年龄、锁的指针（是否占有锁，占有哪个锁）等信息。

  32位系统，普通对象的对象头：
  ```
  hash:25 ------------>| age:4  biased_lock:1   lock:2
  ```
  25位比特表示对象的哈希值，4位比特表示对象的年龄，1位比特表示是否为偏向锁，2位比特表示锁的信息。

  偏向锁对象格式如下：
  ```
  [JavaThread*  |   epoch   |   age |   1   |   01]
  ```
  前23位比特表示持有偏向锁的线程，后续2位比特表示偏向锁的时间戳（epoch），4位比特表示对象年龄，年龄后1位比特固定为1，表示偏向锁，最后2位为01表示可偏向/未锁定。

  当对象处于轻量级锁锁定时，Mark Word 如下（00表示最后两位的值）：
  ```
  [ptr  |   00] locked
  ```
  此时，它指向存放在获得锁的线程栈中的该对象真实对象头。

  当对象处于重量级锁定时，Mark Word 如下：
  ```
  [ptr  |   01] monitor
  ```
  此时，最后2位为10，整个 Mark Word 表示指向 Monitor 的指针。

  对象处于普通的未锁定状态，格式如下：
  ```
  [header   |   0   |   01] unlocked
  ```
  前29位表示对象的哈希值、年龄等信息。倒数第3位为0，最后两位01，表示未锁定。可以发现，最后两位的值和偏向状态时是一样的，此时，虚拟机正是通过倒数第3位比特来区分是否是偏向锁。

### 8.2 避免残酷的竞争：锁在 Java 虚拟机中的实现和优化
  在多线程程序中，线程之间的竞争是不可避免的，而且是一种常态，如何使用更高的效率处理多线程的竞争，是 Java 虚拟机一项重要的使命。

#### 8.2.1 偏向锁
  偏向锁是JDK1.6提出的一种锁优化的方式。其核心思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。也就是说，若某一锁被线程获取后，便进入偏向模式；当线程再次请求这个锁时，无需再进行相关的同步操作，从而节省了操作时间；如果在此之间有其他线程进行了锁请求，则锁退出偏向模式。`-XX:+UseBiasedLocking`可以设置启用偏向锁。

  当锁对象处于偏向模式时，对象头会记录获得锁的线程：
  ```
  [JavaThread*  |   epoch   |   age |   1   |   01]
  ```

  [偏向锁](../java/com/ibgdn/chapter_8/Biased.java)
  输出结果：
  ```
  686
  ```
  使用一个线程对 Vector 进行写入操作，由于对 Vector 的访问，其内部都是用同步锁控制，故每次 add 操作都会请求 numberList 对象的锁。

  VM options：
  ```
  -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 -client -Xmx512m -Xms512m
  ```

  输出结果：
  ```
  319
  ```
  `-XX:BiasedLockingStartupDelay`表示虚拟机在启动后，立即启用偏向锁。如果不设置该参数，虚拟机默认会在启动4秒后，才启用偏向锁，考虑到程序运行时间较短，故做此设置。

  **偏向锁在锁竞争的激烈的场合没有太强的优化效果**。因为大量的竞争会导致持有锁的线程不停地切换，锁也很难一直保持在偏向模式，此时，使用锁偏向不仅得不到性能的优化，反而有可能降低系统性能。在激烈竞争的场合，可以尝试使用`-XX:-UseBasedLocking`参数禁用偏向锁。

#### 8.2.2 轻量级锁
  如果偏向锁失败，Java 虚拟机会让线程申请轻量级锁。轻量级锁在虚拟机内部，使用一个称为 BasicObjectLock 的对象实现，这个对象内部由一个 BasicLock 对象和一个持有该锁的 Java 对象指针组成。BasicObjectLock 对象放置在 Java 栈的栈帧中。在 BasicLock 对象内部还维护着 displaced_header 字段，它用于备份对象头部的 Mark Word。

  一个线程持有一个对象的锁时，对象头部 Mark Word：
  ```
  [ptr  | 00] locked
  ```

  末尾两位比特为00，整个 Mark Word 为指向 BasicLock 对象的指针。由于 BasicObjectLock 对象在线程栈中，因此该指针必然指向持有该锁的线程栈空间。当需要判断某一线程是否持有该对象锁时，也只需简单地判断对象头的指针是否在当前线程的栈地址范围内即可。同时，BasicLock 对象的 displaced_header 字段，备份了原对象的 Mark Word 内容。BasicObjectLock 对象的 obj 字段则指向该对象。

  轻量级锁核心代码
  ```java
  markOop mark = obj -> mark();
  lock -> set_displaced_header(mark);
  if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj() -> mark_addr(), mark)) {
    TEVENT (slow_enter: release stacklock);
    return ;
  }
  ```

  首先，BasicLock 通过 set_displaced_header() 方法备份了原对象的 Mark Word。接着，使用 CAS 操作，尝试将 BasicLock 的地址复制到对象头的 Mark Word。如果复制成功，那么加锁成功，否则认为加锁失败。如果加锁失败，那么轻量级锁就有可能被膨胀为重量级锁。

#### 8.2.3 锁膨胀
  当轻量级锁失败，虚拟机就会使用重量级锁，同时 Mark Word 为：
  ```
  [ptr  | 10] monitor
  ```

  末尾2比特标记位被置为10。整个 Mark Word 表示指向 monitor 对象的指针。在轻量级锁处理失败后，虚拟机会执行如下操作：
  ```java
  lock -> set_displaced_header(markOopDesc::unused_mark());
  ObjectSynchronizer::inflate(THREAD, obj()) -> enter(THREAD);
  ```

  首先，废弃前面 BasicLock 备份的对象头信息。然后，正式启用重量级锁，启用过程分两步：通过`inflate()`进行锁膨胀，以获得对象的 ObjectMonitor；然后使用`enter()`方法尝试进入该锁。

  在`enter()`方法调用时，线程很可能会在操作系统层面被挂起，线程间切换和调度的成本就会比较高。