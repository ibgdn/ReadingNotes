### 8.1 完全就是锁存在的理由：锁的基本概念和实现
  锁是多线程软件开发的必要工具之一，它的基本作用是保护临界区资源不会被多个线程同时访问而受到破坏。如果由于多线程访问造成对象数据的不一致，那么系统运行将会得到错误的结果。通过锁，可以让多个线程排队，一个一个地进入临界区访问目标对象，使目标对象的状态总是保持一致，这也就是锁存在的价值。

#### 8.1.1 理解线程安全
  通过锁，可以实现线程安全。对于线程安全，简单的理解就是，在多线程环境下，无论多个线程如何访问目标对象，目标对象的状态应该始终是保持一致的，线程的行为也总是正确的。

  简单示例说明线程安全：

  线程 A 和线程 B 在数据库中分别读入两条学生成绩记录，线程 A 读入小明98分，线程 B 读入小王考77分。现在需要将从数据库里得到的数据保存到对象实例 S 上，在进行其他相应的业务逻辑处理。此时，对象实例 S 就是临界区资源。如果没有锁对 S 进行保护，任由两个线程随意处理，由于线程间的无序性访问，一种可能的访问结果是：线程 A 将学生名“小明”赋予对象 S，接着线程 B 将学生名“小王”赋予对象 S，覆盖线程 A 的操作。然后，线程 B 将成绩77分赋予对象 S，最后线程 A 将成绩98分赋予对象 S，覆盖了线程 B 的操作。这一组操作得到的结果是，对象 S 中保存了部分小明的数据（成绩），部分小王的数据（学生名），显然这样一个对象是没有任何意义的，也就是对象处于一种不一致的状态，这也正是线程不安全导致的恶果。

  要处理这个问题就可以使用锁来解决。对于对象 S 的所有操作使用锁进行控制，每一次只允许一个线程对其操作，如果线程 A 先获得锁，那么线程 A 将完成它对对象 S 的所有处理，最后释放锁。而线程 B 由于没能请求到锁，就会进行等待，直到线程 A 释放了锁，线程 B 才得以获得锁。在这种情况下，只有在被锁保护的代码段内，对象的状态会出现短暂的不一致（幸运的是，这种状态被锁保护，因此其他线程也无法观察到这种状态），但只要线程 A 或者线程 B 完成了它的工作，对象 S 的状态就是一致的，即对象 S 保存的数据不是小明的，就是小王的，而不是两者的混合体。

  数据的不一致不仅会使得程序给出错误的结果，也可能导致程序异常崩溃。

  [ArrayList 在多线程下使用](../java/com/ibgdn/chapter_8/ThreadUnSafe.java)

  两个线程同时向 List 集合中增加数据，由于 ArrayList 不是线程安全的，很可能抛出如下错误（也有可能不出错）。

  输出结果：
  ```
  Exception in thread "Thread-1" java.lang.ArrayIndexOutOfBoundsException: 10
	  at java.util.ArrayList.add(ArrayList.java:463)
	  at com.ibgdn.chapter_8.ThreadUnSafe$AddToList.run(ThreadUnSafe.java:35)
	  at java.lang.Thread.run(Thread.java:748)
  ```

  出现这个问题，是因为两个线程同时对 ArrayList 进行写操作，破坏了 ArrayList 内部数据的一致性，导致其中一个线程访问了错误的数组索引。简单的修正方法是使用 Vector 代替 ArrayList，Vector 通过内部锁实现对 List 对象控制。